{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "#import os\n",
    "from selenium import webdriver\n",
    "from selenium.webdriver.common.by import By\n",
    "from selenium.webdriver.support.ui import WebDriverWait\n",
    "from selenium.webdriver.chrome.options import Options\n",
    "from selenium.webdriver.support import expected_conditions as EC\n",
    "from selenium.webdriver.chrome.service import Service\n",
    "from webdriver_manager.chrome import ChromeDriverManager\n",
    "import pandas as pd\n",
    "#import numpy as np\n",
    "from selenium.webdriver.support.ui import Select\n",
    "\n",
    "from selenium.common.exceptions import TimeoutException, WebDriverException, StaleElementReferenceException\n",
    "import time\n",
    "\n",
    "s = Service(ChromeDriverManager().install())\n",
    "\n",
    "#option.add_argument(\"--window-size=1920,1080\")  # Adjust window size\n",
    "#option.add_argument(\"--disable-extensions\")  # Disable Chrome extensions\n",
    "\n",
    "#path = \"C:\\Users\\dillonk\\.cache\\selenium\\chromedriver\\win64\\124.0.6367.207\\chromedriver.exe\"\n",
    "\n",
    "def create_webdriver():\n",
    "    chrome_options = webdriver.ChromeOptions()\n",
    "    chrome_options.add_argument('--no-sandbox')\n",
    "    chrome_options.add_argument('--disable-dev-shm-usage')\n",
    "    chrome_options.add_argument('--headless')  # Remove this if you want to run in non-headless mode\n",
    "    chrome_options.add_argument('--disable-gpu')\n",
    "    chrome_options.add_argument('--window-size=1920x1080')\n",
    "    chrome_options.add_argument('--disable-extensions')\n",
    "    chrome_options.add_argument('--disable-infobars')\n",
    "    chrome_options.add_argument('--disable-browser-side-navigation')\n",
    "    chrome_options.add_argument('--disable-dev-shm-usage')  # Overcome limited resource problems\n",
    "    chrome_options.add_argument('--remote-debugging-port=9222')\n",
    "    chrome_options.add_argument('--disable-software-rasterizer')\n",
    "    chrome_options.add_argument('--disable-features=VizDisplayCompositor')\n",
    "\n",
    "    # Increase memory limits\n",
    "    chrome_options.add_argument('--max_old_space_size=4096')\n",
    "\n",
    "    service = Service(executable_path= driver_path)  # Update with the path to your chromedriver\n",
    "    driver = webdriver.Chrome(service=s, options=chrome_options)\n",
    "    return driver\n",
    "\n",
    "driver_path = r'C:\\Users\\dillonk\\.wdm\\drivers\\chromedriver\\win64\\125.0.6422.60\\chromedriver.exe'\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Away Teams: ['KC', 'NYM', 'CLE']\n",
      "Home Teams: ['NYY', 'LAD', 'DET']\n"
     ]
    }
   ],
   "source": [
    "\n",
    "\n",
    "url_oddstrader= \"https://www.oddstrader.com/mlb/\"\n",
    "\n",
    "# Function to load the page with retry mechanism\n",
    "def load_page_with_retry(driver, url, retries=3, delay=8):\n",
    "    attempt = 0\n",
    "    while attempt < retries:\n",
    "        try:\n",
    "            driver.get(url)\n",
    "            return True\n",
    "        except (TimeoutException, WebDriverException) as e:\n",
    "            print(f\"Attempt {attempt + 1} failed. Retrying in {delay} seconds... Error: {e}\")\n",
    "            time.sleep(delay)\n",
    "            attempt += 1\n",
    "    return False\n",
    "\n",
    "# Create a WebDriver instance\n",
    "driver = create_webdriver()\n",
    "\n",
    "# Attempt to load the page with retries\n",
    "if load_page_with_retry(driver, url_oddstrader):\n",
    "    try:\n",
    "        # Extract team names and game days\n",
    "        ot_all_teams_list = WebDriverWait(driver, 8).until(\n",
    "            EC.presence_of_all_elements_located((By.XPATH, '//span[@class=\"teamName blueHover\"]'))\n",
    "        )\n",
    "\n",
    "        day_of_game = WebDriverWait(driver, 8).until(\n",
    "            EC.presence_of_all_elements_located((By.XPATH, '//span[@class=\"generalDay\"]'))\n",
    "        )\n",
    "\n",
    "        ot_away_teams_list = []\n",
    "        ot_home_teams_list = []\n",
    "\n",
    "        def gameday_checker(day_element):\n",
    "            gamedays = {\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"}\n",
    "            return any(day in day_element.text for day in gamedays)\n",
    "\n",
    "        team_index = 0\n",
    "        # Iterate over the days to filter and collect team names\n",
    "        for day_element in day_of_game:\n",
    "            if gameday_checker(day_element):\n",
    "                if team_index < len(ot_all_teams_list) - 1:\n",
    "                    ot_away_teams_list.append(ot_all_teams_list[team_index].text)\n",
    "                    ot_home_teams_list.append(ot_all_teams_list[team_index + 1].text)\n",
    "                team_index += 3\n",
    "\n",
    "        # Print the lists of away and home teams\n",
    "        print(\"Away Teams:\", ot_away_teams_list)\n",
    "        print(\"Home Teams:\", ot_home_teams_list)\n",
    "\n",
    "    except TimeoutException as te:\n",
    "        print(\"Timeout occurred while waiting for elements:\", te)\n",
    "        # Log page source for debugging\n",
    "        with open('page_source.html', 'w', encoding='utf-8') as f:\n",
    "            f.write(driver.page_source)\n",
    "else:\n",
    "    print(\"Failed to load the page after several attempts.\")\n",
    "\n",
    "# Close the driver\n",
    "driver.quit()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Away Odds (US): ['-112', '+130', '-110']\n",
      "Home Odds (US): ['-104', '-148', '-104']\n",
      "Away Odds (UK): [1.89, 2.3, 1.91]\n",
      "Home Odds (UK): [1.96, 1.68, 1.96]\n"
     ]
    }
   ],
   "source": [
    "\n",
    "# Create a WebDriver instance\n",
    "driver = create_webdriver()\n",
    "\n",
    "if driver is not None:\n",
    "\n",
    "    # Attempt to load the page with retries\n",
    "    if load_page_with_retry(driver, url_oddstrader):\n",
    "        try:\n",
    "            # Extract the odds\n",
    "            ot_all_odds_list = WebDriverWait(driver, 3).until(\n",
    "                EC.presence_of_all_elements_located((By.XPATH, '//span[@class=\"best-line\"]'))\n",
    "            )\n",
    "\n",
    "            ot_best_home_odds_list = []\n",
    "            ot_best_away_odds_list = []\n",
    "\n",
    "            i = 0\n",
    "            while i < len(ot_away_teams_list) + len(ot_home_teams_list):\n",
    "                if i % 2 == 0:\n",
    "                    ot_best_away_odds_list.append(ot_all_odds_list[i].text)\n",
    "                else:\n",
    "                    ot_best_home_odds_list.append(ot_all_odds_list[i].text)\n",
    "                i += 1\n",
    "\n",
    "            # Convert US odds to UK odds\n",
    "            def convert_odds_to_uk(us_odds_list):\n",
    "                uk_odds_list = []\n",
    "                for us_odd in us_odds_list:\n",
    "                    if us_odd.lower() == 'even':\n",
    "                        uk_odd = 2.0\n",
    "                    elif us_odd == '-':\n",
    "                        uk_odd = 1.0  # Representing a loss of the bet as 100% loss (decimal odds of 1.0)\n",
    "                    else:\n",
    "                        try:\n",
    "                            us_odd = int(us_odd)\n",
    "                            if us_odd > 0:\n",
    "                                uk_odd = (us_odd / 100) + 1\n",
    "                            else:\n",
    "                                uk_odd = (100 / abs(us_odd)) + 1\n",
    "                        except ValueError:\n",
    "                            uk_odd = 1.0  # Default to 1.0 if there's an error converting the odd\n",
    "                    uk_odds_list.append(round(uk_odd, 2))\n",
    "                return uk_odds_list\n",
    "\n",
    "            ot_best_away_odds_us = ot_best_away_odds_list.copy()\n",
    "            ot_best_home_odds_us = ot_best_home_odds_list.copy()\n",
    "\n",
    "            ot_best_away_odds_uk = convert_odds_to_uk(ot_best_away_odds_list)\n",
    "            ot_best_home_odds_uk = convert_odds_to_uk(ot_best_home_odds_list)\n",
    "\n",
    "            # Print odds data\n",
    "            print(\"Away Odds (US):\", ot_best_away_odds_us)\n",
    "            print(\"Home Odds (US):\", ot_best_home_odds_us)\n",
    "\n",
    "            print(\"Away Odds (UK):\", ot_best_away_odds_uk)\n",
    "            print(\"Home Odds (UK):\", ot_best_home_odds_uk)\n",
    "\n",
    "        except TimeoutException as te:\n",
    "            print(\"Timeout occurred while waiting for elements:\", te)\n",
    "            # Log page source for debugging\n",
    "            with open('page_source.html', 'w', encoding='utf-8') as f:\n",
    "                f.write(driver.page_source)\n",
    "    else:\n",
    "        print(\"Failed to load the page after several attempts.\")\n",
    "    \n",
    "    # Close the driver\n",
    "    driver.quit()\n",
    "else:\n",
    "    print(\"WebDriver creation failed. Exiting...\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best Away Sites: ['FanDuel', 'Caesars', 'Caesars']\n",
      "Best Home Sites: ['BetRivers', 'BetRivers', 'FanDuel']\n"
     ]
    }
   ],
   "source": [
    "# Create a WebDriver instance\n",
    "driver = create_webdriver()\n",
    "\n",
    "if driver is not None:\n",
    "\n",
    "    # Attempt to load the page with retries\n",
    "    if load_page_with_retry(driver, url_oddstrader):\n",
    "        try:\n",
    "            # Extract the best sites\n",
    "            ot_all_best_sites = WebDriverWait(driver, 7).until(\n",
    "                EC.presence_of_all_elements_located((By.XPATH, '//span[@class=\"subtitle\"]'))\n",
    "            )\n",
    "\n",
    "            retry_count = 5\n",
    "            while retry_count > 0:\n",
    "                try:\n",
    "                    ot_all_best_sites_text = [elem.text for elem in ot_all_best_sites if elem.text.strip() != \"ODDS BY\"]\n",
    "                    # Only take the sites for the indexes up to the length of ot_home_teams_list\n",
    "                    ot_best_away_sites = [site for site in ot_all_best_sites_text[:2 * len(ot_home_teams_list):2] if site.strip()]\n",
    "                    ot_best_home_sites = [site for site in ot_all_best_sites_text[1:2 * len(ot_home_teams_list):2] if site.strip()]\n",
    "\n",
    "                    break  # Exit the loop if successful\n",
    "                except StaleElementReferenceException:\n",
    "                    retry_count -= 1\n",
    "\n",
    "            if retry_count == 0:\n",
    "                print(\"Failed to retrieve element text due to StaleElementReferenceException\")\n",
    "\n",
    "            # Print the best sites lists\n",
    "            print(\"Best Away Sites:\", ot_best_away_sites)\n",
    "            print(\"Best Home Sites:\", ot_best_home_sites)\n",
    "\n",
    "        except TimeoutException as te:\n",
    "            print(\"Timeout occurred while waiting for elements:\", te)\n",
    "            # Log page source for debugging\n",
    "            with open('page_source.html', 'w', encoding='utf-8') as f:\n",
    "                f.write(driver.page_source)\n",
    "    else:\n",
    "        print(\"Failed to load the page after several attempts.\")\n",
    "    \n",
    "    # Close the driver\n",
    "    driver.quit()\n",
    "else:\n",
    "    print(\"WebDriver creation failed. Exiting...\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.5291005291005292, 0.4347826086956522, 0.5235602094240838]\n",
      "[0.5102040816326531, 0.5952380952380952, 0.5102040816326531]\n"
     ]
    }
   ],
   "source": [
    "#coverting uk odds from oddstrader into away prob and home prob \n",
    "\n",
    "ot_home_probablity_odds = []\n",
    "for odds in ot_best_home_odds_uk: \n",
    "    ot_home_probablity_odds.append(1 /odds)\n",
    "\n",
    "ot_away_probablity_odds = []\n",
    "for odds in ot_best_away_odds_uk: \n",
    "    ot_away_probablity_odds.append(1 /odds)\n",
    "\n",
    "print(ot_away_probablity_odds)\n",
    "print(ot_home_probablity_odds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calc_home_stake(implied_home_prob, implied_away_prob, total_wager):\n",
    "    total_implied_prob = implied_home_prob + implied_away_prob\n",
    "    scaling_factor = total_wager / total_implied_prob\n",
    "    home_stake = implied_home_prob * scaling_factor\n",
    "    home_stake = round(home_stake, 2)\n",
    "    \n",
    "    return home_stake\n",
    "\n",
    "def calc_away_stake(implied_home_prob, implied_away_prob, total_wager):\n",
    "    total_implied_prob = implied_home_prob + implied_away_prob\n",
    "    scaling_factor = total_wager / total_implied_prob\n",
    "    away_stake = implied_away_prob * scaling_factor\n",
    "    away_stake = round(away_stake, 2)\n",
    "    \n",
    "    return away_stake\n",
    "\n",
    "#print(calc_home_stake(0.7462686567164178, 0.28169014084507044, 100))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "#calculating optimal percentage profit (guaranteed):\n",
    "\n",
    "def calc_opt_perc_profit(implied_home_prob, implied_away_prob):\n",
    "    total_implied_prob = implied_home_prob + implied_away_prob\n",
    "    scaling_factor = 1 / total_implied_prob\n",
    "    home_stake = implied_home_prob * scaling_factor\n",
    "    away_stake = implied_away_prob * scaling_factor\n",
    "    home_payout = home_stake * (1 / implied_home_prob)\n",
    "    away_payout = away_stake * (1 / implied_away_prob)\n",
    "    guaranteed_profit = max(home_payout, away_payout) - 1\n",
    "    percentage_profit = round(guaranteed_profit * 100, 2)\n",
    "    return f\"{percentage_profit}%\"\n",
    "\n",
    "def calc_dollar_profit(implied_home_prob, implied_away_prob):\n",
    "    total_implied_prob = implied_home_prob + implied_away_prob\n",
    "    scaling_factor = 1 / total_implied_prob\n",
    "    home_stake = implied_home_prob * scaling_factor\n",
    "    away_stake = implied_away_prob * scaling_factor\n",
    "    home_payout = home_stake * (1 / implied_home_prob)\n",
    "    away_payout = away_stake * (1 / implied_away_prob)\n",
    "    guaranteed_profit = max(home_payout, away_payout) - 1\n",
    "    dollar_profit = round(guaranteed_profit * 100, 2)\n",
    "    return f\"${dollar_profit}\"\n",
    "  \n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "No Current Arbitrage Opportunities\n",
      "No Current Arbitrage Opportunities\n",
      "No Current Arbitrage Opportunities\n",
      "['-112', '+130', '-110']\n",
      "['-104', '-148', '-104']\n"
     ]
    }
   ],
   "source": [
    "#loop through the home and away OT odds to see if any are arb opps: \n",
    "    # append all info to new lists if are \n",
    "\n",
    "ot_arb_away_team = []\n",
    "ot_arb_home_team = []\n",
    "ot_arb_away_odds = []\n",
    "ot_arb_home_odds = []\n",
    "ot_arb_away_site = []\n",
    "ot_arb_home_site = []\n",
    "ot_arb_away_wager_amount = []\n",
    "ot_arb_home_wager_amount = []\n",
    "ot_arb_perc_profit = []\n",
    "ot_arb_dollar_profit = []\n",
    "\n",
    "# Ensure both lists have the same length\n",
    "if len(ot_away_probablity_odds) == len(ot_home_probablity_odds):\n",
    "    for i in range(len(ot_away_probablity_odds)):\n",
    "        if ot_away_probablity_odds[i] + ot_home_probablity_odds[i] < 1:\n",
    "            ot_arb_away_team.append(ot_away_teams_list[i])\n",
    "            ot_arb_home_team.append(ot_home_teams_list[i])\n",
    "            ot_arb_away_odds.append(ot_best_away_odds_us[i])\n",
    "            ot_arb_home_odds.append(ot_best_home_odds_us[i])\n",
    "            ot_arb_away_site.append(ot_best_away_sites[i])\n",
    "            ot_arb_home_site.append(ot_best_home_sites[i])\n",
    "            ot_arb_away_wager_amount.append(calc_away_stake(ot_home_probablity_odds[i], ot_away_probablity_odds[i], 100))\n",
    "            ot_arb_home_wager_amount.append(calc_home_stake(ot_home_probablity_odds[i], ot_away_probablity_odds[i], 100))\n",
    "            ot_arb_perc_profit.append(calc_opt_perc_profit(ot_home_probablity_odds[i], ot_away_probablity_odds[i]))\n",
    "            ot_arb_dollar_profit.append(calc_dollar_profit(ot_home_probablity_odds[i], ot_away_probablity_odds[i])) \n",
    "        else: \n",
    "            print(\"No Current Arbitrage Opportunities\") \n",
    "\n",
    "\n",
    "print(ot_best_away_odds_us) \n",
    "print(ot_best_home_odds_us) \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'Home Team': [], 'Away Team': [], 'Home Odds': [], 'Away Odds': [], 'Home Book': [], 'Away Book': [], 'Home wager': [], 'Away wager': [], 'Profit(%)': [], 'Profit($)': []}\n"
     ]
    }
   ],
   "source": [
    "#making a dict for all the essential arb info \n",
    "\n",
    "arb_opps_info = {\"Home Team\": ot_arb_home_team, \"Away Team\": ot_arb_away_team, \"Home Odds\": ot_arb_home_odds, \"Away Odds\": ot_arb_away_odds, \"Home Book\": ot_arb_home_site, \"Away Book\": ot_arb_away_site, \"Home wager\":ot_arb_home_wager_amount, \"Away wager\": ot_arb_away_wager_amount, \"Profit(%)\": ot_arb_perc_profit, \"Profit($)\": ot_arb_dollar_profit}\n",
    "print(arb_opps_info)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Home Team</th>\n",
       "      <th>Away Team</th>\n",
       "      <th>Home Odds</th>\n",
       "      <th>Away Odds</th>\n",
       "      <th>Home Book</th>\n",
       "      <th>Away Book</th>\n",
       "      <th>Home wager</th>\n",
       "      <th>Away wager</th>\n",
       "      <th>Profit(%)</th>\n",
       "      <th>Profit($)</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "Empty DataFrame\n",
       "Columns: [Home Team, Away Team, Home Odds, Away Odds, Home Book, Away Book, Home wager, Away wager, Profit(%), Profit($)]\n",
       "Index: []"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#making df for arb opps info\n",
    "df_arb = pd.DataFrame.from_dict(arb_opps_info)\n",
    "df_arb\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "No current abritrage opportunities\n"
     ]
    }
   ],
   "source": [
    "import smtplib\n",
    "from email.mime.multipart import MIMEMultipart\n",
    "from email.mime.text import MIMEText\n",
    "\n",
    "\n",
    "def send_email(x):\n",
    "    MY_ADDRESS = \"[name]@outlook.com\"\n",
    "    MY_PASSWORD = \"[standard password]\"\n",
    "    RECIPIENT_ADDRESS = \"[standard email]\"\n",
    "\n",
    "    HOST_ADDRESS = \"smtp-mail.outlook.com\"\n",
    "    HOST_PORT = 587\n",
    "\n",
    "    # Set up the SMTP server\n",
    "    server = smtplib.SMTP(host=HOST_ADDRESS, port=HOST_PORT)\n",
    "    server.starttls()\n",
    "    server.login(MY_ADDRESS, MY_PASSWORD)\n",
    "\n",
    "    # Create the email\n",
    "    message = MIMEMultipart()\n",
    "    message[\"From\"] = MY_ADDRESS\n",
    "    message[\"To\"] = RECIPIENT_ADDRESS\n",
    "    message[\"Subject\"] = \"Arbitrage Opportunity\"\n",
    "\n",
    "# Convert DataFrame to HTML table\n",
    "    html_table = x.to_html(index=False)\n",
    "\n",
    "    # Attach the HTML table to the email body\n",
    "    htmlPart = MIMEText(html_table, 'html')\n",
    "    message.attach(htmlPart)\n",
    "\n",
    "    # Send the email\n",
    "    server.send_message(message)\n",
    "    server.quit()\n",
    "\n",
    "    print(\"email sent successfully\")\n",
    "\n",
    "# Send email if condition is met\n",
    "def check_condition():\n",
    "    if ot_away_probablity_odds[i] + ot_home_probablity_odds[i] < 1:\n",
    "        send_email(df_arb)\n",
    "    else: print(\"No current abritrage opportunities\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    check_condition()\n",
    "\n",
    "    \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "myenv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
